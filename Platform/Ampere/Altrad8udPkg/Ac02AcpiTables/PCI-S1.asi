/** @file

  Copyright (c) 2023, Ampere Computing LLC. All rights reserved.<BR>

  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

//
// S1 Start here
//

// PCIE6 S1 RCA2
Device (PCIA) {
  //
  // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
  // Section 6.1.5
  //

  Name (_HID,"PNP0A08")
  Name (_CCA, ONE)

  Method (_STA, 0, NotSerialized) {
    Return (0xF)
  }

  //
  // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
  // root complex for use with pre-PCIe operating systems.
  // Section 6.1.2
  //

  Name (_CID,"PNP0A03")

  //
  // Declare the segment number of this root complex. Most systems only
  // have one segment, which is numbered 0.
  // Section 6.5.6
  //

  Name (_SEG, 6)

  //
  // Declare the base bus number, which is the bus number of the root
  // bus in this root complex. This is usually 0, but need not be.
  // For root complexes supporting multiple root busses, this should
  // be the lowest numbered root bus.
  // Section 6.5.5
  //

  Name (_BBN, 0)

  //
  // The _UID value provides a way of uniquely identifying a device
  // in the case where more than one instance of a specific device
  // is implemented with the same _HID/_CID. For systems with a
  // single root complex, this is usually just 0. For systems with
  // multiple root complexes, this should be different for each
  // root complex.
  // Section 6.1.12
  //

  Name (_UID, "PCIA")
  Name (_STR, Unicode("PCIe 10 Device"))

  //
  // Declare the PCI Routing Table.
  // This defines SPI mappings of the four line-based interrupts
  // associated with the root complex and hierarchy below it.
  // Section 6.2.12
  //

  Name (_PRT, Package() {

    //
    // Routing for device 0, all functions.
    // Note: ARM doesn't support LNK nodes, so the third param
    // is 0 and the fourth param is the SPI number of the interrupt
    // line. In this example, the A/B/C/D interrupts are wired to
    // SPI lines 136/137/138/139 + 320 respectively. PCIA RCA2
    //
    Package() {0x0001FFFF, 0, 0, 456},
    Package() {0x0001FFFF, 1, 0, 457},
    Package() {0x0001FFFF, 2, 0, 458},
    Package() {0x0001FFFF, 3, 0, 459},
    Package() {0x0002FFFF, 0, 0, 456},
    Package() {0x0002FFFF, 1, 0, 457},
    Package() {0x0002FFFF, 2, 0, 458},
    Package() {0x0002FFFF, 3, 0, 459},
    Package() {0x0003FFFF, 0, 0, 456},
    Package() {0x0003FFFF, 1, 0, 457},
    Package() {0x0003FFFF, 2, 0, 458},
    Package() {0x0003FFFF, 3, 0, 459},
    Package() {0x0004FFFF, 0, 0, 456},
    Package() {0x0004FFFF, 1, 0, 457},
    Package() {0x0004FFFF, 2, 0, 458},
    Package() {0x0004FFFF, 3, 0, 459},
  })

  //
  // Declare the resources assigned to this root complex.
  // Section 6.2.2
  //
  Method (_CBA, 0, Serialized) {
    Return (0x7BFFF0000000)
  }

  Name (RBUF, ResourceTemplate () {

    //
    // Declare the range of bus numbers assigned to this root
    // complex. In this example, the minimum bus number will be
    // 0, the maximum bus number will be 0xFF, supporting
    // 256 busses total.
    // Section 19.5.141
    //

    WordBusNumber (
      ResourceProducer,
      MinFixed,   // IsMinFixed
      MaxFixed,   // IsMaxFixed
      PosDecode,  // Decode
      0,          // AddressGranularity
      0,          // AddressMinimum - Minimum Bus Number
      255,        // AddressMaximum - Maximum Bus Number
      0,          // AddressTranslation - Set to 0
      256)        // RangeLength - Number of Busses

    //
    // Declare the memory range to be used for BAR memory
    // windows. This declares a 4GB region starting at
    // 0x4000000000.
    // Section 19.5.80
    //
    // Memory32Fixed (ReadWrite, 0x1FF80000, 0x10000, )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000000070000000,   // AddressMinimum - MIN
      0x0000000077FFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x0000000008000000    // RangeLength - LEN
    )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000780000000000,   // AddressMinimum - MIN
      0x00007BFFDFFFFFFF,   // AddressMaximum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x000003FFE0000000    // RangeLength - LEN
    )
  })

  Method (_CRS, 0, Serialized) {
    Return (RBUF)
  }

  //
  // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
  //
  // Argments:
  //   Arg0  A Buffer containing a UUID
  //   Arg1  An Integer containing a Revision ID of the buffer format
  //   Arg2  An Integer containing a count of entries in Arg3
  //   Arg3  A Buffer containing a list of DWORD capabilities
  // Return Value:
  //   A Buffer containing a list of capabilities
  // See the APCI spec, Section 6.2.10,
  // and the PCI FW spec, Section 4.5.
  //
  // The following is an example, and may need modification for
  // specific implementations.
  //

  Name (SUPP,0) // PCI _OSC Support Field value
  Name (CTRL,0) // PCI _OSC Control Field value

  Method (_OSC, 4) {

    //
    // Look for the PCI Host Bridge Interface UUID.
    // Section 6.2.10.3
    //

    //
    // Create DWord-adressable fields from the Capabilities Buffer
    // Create CDW1 outside the test as it's used in the else clause.
    //

    CreateDWordField (Arg3,0,CDW1)
    If (LEqual (Arg0,ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

      CreateDWordField (Arg3,4,CDW2)
      CreateDWordField (Arg3,8,CDW3)

      //
      // Save Capabilities DWord 2 & 3
      //

      Store (CDW2,SUPP)
      Store (CDW3,CTRL)

      //
      // Only allow native hot plug control if OS supports:
      //  ASPM
      //  Clock PM
      //  MSI/MSI-X
      //

      If (LNotEqual (And (SUPP, 0x16), 0x16)) {

        //
        // Mask bit 0 (and undefined bits)
        //

        And (CTRL,0x1E,CTRL)
      }

      //
      // Never allow native Hot plug, PME.
      // Never allow SHPC (no SHPC controller in this system).
      // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
      // Allows PCI Express Capability Structure control
      //

      if (AERF) {
        And (CTRL, 0x10, CTRL)
      } Else {
        And (CTRL, 0x18, CTRL)
      }

      //
      // Check for unknown revision.
      //

      If (LNotEqual (Arg1,One)) {
        Or (CDW1,0x08,CDW1)
      }

      //
      // Check if capabilities bits were masked.
      //

      If (LNotEqual (CDW3,CTRL)) {
        Or (CDW1,0x10,CDW1)
      }

      //
      // Update DWORD3 in the buffer.
      //

      Store (CTRL,CDW3)
      Return (Arg3)
    } Else {

      //
      // Unrecognized UUID
      //

      Or (CDW1,4,CDW1)
      Return (Arg3)
    }
  } // End _OSC

  //
  // Declare a _DSM method for various functions called by the OS.
  // See the APCI spec, Section 9.14.1,
  // and the PCI FW spec, Section 4.6.
  // See also:
  // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
  //

  Method (_DSM, 0x4, Serialized) {

    //
    // Match against the _DSM PCI GUID.
    //

    If (LEqual (Arg0,ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

      Switch (ToInteger(Arg2)) {
        //
        // Function 0: Return supported functions as a bitfield
        // with one bit for each supported function.
        // Bit 0 must always be set, as that represents
        // function 0 (which is what is being called here).
        // Support for different functions may depend on
        // the revision ID of the interface, passed as Arg1.
        //

        Case (0) {

            //
            // Functions 0-7 are supported.
            //

            Return (Buffer() {0x01})
        }
      }
    }

    //
    // If not one of the function identifiers we recognize, then return a buffer
    // with bit 0 set to 0 indicating no functions supported.
    //

    Return (Buffer() {0})
  }

  //
  // Root Port 0 Device within the Root Complex.
  //
  Device (RP0) {
    //
    // Device 0, Function 0.
    //

    Name (_ADR, 0x00000000)
  }

  //
  // Root Port 1
  //
  Device (P2P1) {
    //
    // Device 1, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00010000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 1 ([01])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A120 == 0xF0000201) { // SW ejected before ?
          Store(0x02000201, A120) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000216, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000216 to DBNS1_10
          Return (0xF)
        }
        elseif (A120 == 0x10000201) { // ejected completed ?
          Store(0x02000201, A120) // clear action value
          Return (0x0)
        }
        elseif ((A120 == 0x01000201) || (A120 == 0x0F000201)) { // inserted ?
          if (A20I == 0x00) {
            Store(0x02000201, A120) // clear action value
          }
          Return (0xF)
        }
        elseif ((A120 == 0x0E000201) || (A120 == 0x0F000201)) { // inprogress inserted ?
          if (A20I == 0x00) {
            Store(0x02000201, A120) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A120 == 0x02000201) { // is sw ejection?
          Store(0xF0000201, A120) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000216, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000216 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000001)
    }
  }

  //
  // Root Port 2
  //
  Device (P2P2) {
    //
    // Device 2, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00020000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 2 ([02])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A121 == 0xF0010201) { // SW ejected before ?
          Store(0x02010201, A121) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000226, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000226 to DBNS1_10
          Return(0xF)
        }
        elseif (A121 == 0x10010201) { // ejected completed ?
          Store(0x02010201, A121) // clear action value
          Return(0x0)
        }
        elseif ((A121 == 0x01010201) || (A121 == 0x0F010201)) { // inserted ?
          if (A21I == 0x00) {
            Store(0x02010201, A121) // clear action value
          }
          Return(0xF)
        }
        elseif ((A121 == 0x0E010201) || (A121 == 0x0F010201)) { // inprogress inserted ?
          if (A21I == 0x00) {
            Store(0x02010201, A121) // clear action value
          }
          Return(0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A121 == 0x02010201) { // is sw ejection?
          Store(0xF0010201, A121) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000226, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000226 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000002)
    }
  }

  //
  // Root Port 3
  //
  Device (P2P3) {
    //
    // Device 3, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00030000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 3 [03])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A122 == 0xF0020201) { // SW ejected before ?
          Store(0x02020201, A122) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000236, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000236 to DBNS1_10
          Return(0xF)
        }
        elseif (A122 == 0x10020201) { // ejected complete ?
          Store(0x02020201, A122) // clear action value
          Return (0x0)
        }
        elseif ((A122 == 0x01020201) || (A122 == 0x0F020201)) { // inserted ?
          if (A22I == 0x00) {
            Store(0x02020201, A122) // clear action value
          }
          Return (0xF)
        }
        elseif ((A122 == 0x0E020201) || (A122 == 0x0F020201)) { // inprogess inserted ?
          if (A22I == 0x00) {
            Store(0x02020201, A122) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A122 == 0x02020201) { // is sw ejection?
          Store(0xF0020201, A122) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000236, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000236 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000003)
    }
  }

  //
  // Root Port 4
  //
  Device (P2P4) {
    //
    // Device 4, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00040000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 4 [04])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A123 == 0xF0030201) { // SW ejected before ?
          Store(0x02030201, A123) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000246, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000246 to DBNS1_10
          Return(0xF)
        }
        elseif (A123 == 0x10030201) { // ejected complete ?
          Store(0x02030201, A123) // clear action value
          Return (0x0)
        }
        elseif ((A123 == 0x01030201) || (A123 == 0x0F030201)) { // inserted ?
          if (A23I == 0x00) {
            Store(0x02030201, A123) // clear action value
          }
          Return (0xF)
        }
        elseif ((A123 == 0x0E030201) || (A123 == 0x0F030201)) { // inprogress inserted ?
          if (A23I == 0x00) {
            Store(0x02030201, A123) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A123 == 0x02030201) { // is sw ejection?
          Store(0xF0030201, A123) // set ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000246, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000246 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000004)
    }
  }

  Method (_PXM, 0, NotSerialized) {
    // Patch by code
    Return(0xFF)
  }
} // PCIA RCA2

// PCIEB RCA3
Device (PCIB) {
  //
  // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
  // Section 6.1.5
  //

  Name (_HID,"PNP0A08")
  Name (_CCA, ONE)

  Method (_STA, 0, NotSerialized) {
    Return (0xF)
  }

  //
  // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
  // root complex for use with pre-PCIe operating systems.
  // Section 6.1.2
  //

  Name (_CID,"PNP0A03")

  //
  // Declare the segment number of this root complex. Most systems only
  // have one segment, which is numbered 0.
  // Section 6.5.6
  //

  Name (_SEG, 7)

  //
  // Declare the base bus number, which is the bus number of the root
  // bus in this root complex. This is usually 0, but need not be.
  // For root complexes supporting multiple root busses, this should
  // be the lowest numbered root bus.
  // Section 6.5.5
  //

  Name (_BBN, 0)

  //
  // The _UID value provides a way of uniquely identifying a device
  // in the case where more than one instance of a specific device
  // is implemented with the same _HID/_CID. For systems with a
  // single root complex, this is usually just 0. For systems with
  // multiple root complexes, this should be different for each
  // root complex.
  // Section 6.1.12
  //

  Name (_UID, "PCIB")
  Name (_STR, Unicode("PCIe 11 Device"))

  //
  // Declare the PCI Routing Table.
  // This defines SPI mappings of the four line-based interrupts
  // associated with the root complex and hierarchy below it.
  // Section 6.2.12
  //

  Name (_PRT, Package() {

    //
    // Routing for device 0, all functions.
    // Note: ARM doesn't support LNK nodes, so the third param
    // is 0 and the fourth param is the SPI number of the interrupt
    // line. In this example, the A/B/C/D interrupts are wired to
    // SPI lines 140/141/142/143 + 320 respectively. PCIB RCA3
    //
    Package() {0x0001FFFF, 0, 0, 460},
    Package() {0x0001FFFF, 1, 0, 461},
    Package() {0x0001FFFF, 2, 0, 462},
    Package() {0x0001FFFF, 3, 0, 463},
    Package() {0x0002FFFF, 0, 0, 460},
    Package() {0x0002FFFF, 1, 0, 461},
    Package() {0x0002FFFF, 2, 0, 462},
    Package() {0x0002FFFF, 3, 0, 463},
    Package() {0x0003FFFF, 0, 0, 460},
    Package() {0x0003FFFF, 1, 0, 461},
    Package() {0x0003FFFF, 2, 0, 462},
    Package() {0x0003FFFF, 3, 0, 463},
    Package() {0x0004FFFF, 0, 0, 460},
    Package() {0x0004FFFF, 1, 0, 461},
    Package() {0x0004FFFF, 2, 0, 462},
    Package() {0x0004FFFF, 3, 0, 463},
  })

  //
  // Declare the resources assigned to this root complex.
  // Section 6.2.2
  //
  Method (_CBA, 0, Serialized) {
    Return (0x7FFFF0000000)
  }

  Name (RBUF, ResourceTemplate () {

    //
    // Declare the range of bus numbers assigned to this root
    // complex. In this example, the minimum bus number will be
    // 0, the maximum bus number will be 0xFF, supporting
    // 256 busses total.
    // Section 19.5.141
    //

    WordBusNumber (
      ResourceProducer,
      MinFixed,   // IsMinFixed
      MaxFixed,   // IsMaxFixed
      PosDecode,  // Decode
      0,          // AddressGranularity
      0,          // AddressMinimum - Minimum Bus Number
      255,        // AddressMaximum - Maximum Bus Number
      0,          // AddressTranslation - Set to 0
      256)        // RangeLength - Number of Busses

    //
    // Declare the memory range to be used for BAR memory
    // windows. This declares a 4GB region starting at
    // 0x4000000000.
    // Section 19.5.80
    //
    // Memory32Fixed (ReadWrite, 0x1FFC0000, 0x10000, )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000000078000000,   // AddressMinimum - MIN
      0x000000007FFFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x0000000008000000    // RangeLength - LEN
    )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x00007C0000000000,   // AddressMinimum - MIN
      0x00007FFFDFFFFFFF,   // AddressMaximum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x000003FFE0000000    // RangeLength - LEN
    )
  })

  Method (_CRS, 0, Serialized) {
    Return (RBUF)
  }

  //
  // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
  //
  // Argments:
  //   Arg0  A Buffer containing a UUID
  //   Arg1  An Integer containing a Revision ID of the buffer format
  //   Arg2  An Integer containing a count of entries in Arg3
  //   Arg3  A Buffer containing a list of DWORD capabilities
  // Return Value:
  //   A Buffer containing a list of capabilities
  // See the APCI spec, Section 6.2.10,
  // and the PCI FW spec, Section 4.5.
  //
  // The following is an example, and may need modification for
  // specific implementations.
  //

  Name (SUPP,0) // PCI _OSC Support Field value
  Name (CTRL,0) // PCI _OSC Control Field value

  Method (_OSC, 4) {

    //
    // Look for the PCI Host Bridge Interface UUID.
    // Section 6.2.10.3
    //

    //
    // Create DWord-adressable fields from the Capabilities Buffer
    // Create CDW1 outside the test as it's used in the else clause.
    //

    CreateDWordField (Arg3,0,CDW1)
    If (LEqual (Arg0,ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

      CreateDWordField (Arg3,4,CDW2)
      CreateDWordField (Arg3,8,CDW3)

      //
      // Save Capabilities DWord 2 & 3
      //

      Store (CDW2,SUPP)
      Store (CDW3,CTRL)

      //
      // Only allow native hot plug control if OS supports:
      //  ASPM
      //  Clock PM
      //  MSI/MSI-X
      //

      If (LNotEqual (And (SUPP, 0x16), 0x16)) {

        //
        // Mask bit 0 (and undefined bits)
        //

        And (CTRL,0x1E,CTRL)
      }

      //
      // Never allow native Hot plug, PME.
      // Never allow SHPC (no SHPC controller in this system).
      // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
      // Allows PCI Express Capability Structure control
      //

      if (AERF) {
        And (CTRL, 0x10, CTRL)
      } Else {
        And (CTRL, 0x18, CTRL)
      }

      //
      // Check for unknown revision.
      //

      If (LNotEqual (Arg1,One)) {
          Or (CDW1,0x08,CDW1)
      }

      //
      // Check if capabilities bits were masked.
      //

      If (LNotEqual (CDW3,CTRL)) {
          Or (CDW1,0x10,CDW1)
      }

      //
      // Update DWORD3 in the buffer.
      //

      Store (CTRL,CDW3)
      Return (Arg3)
    } Else {

      //
      // Unrecognized UUID
      //

      Or (CDW1,4,CDW1)
      Return (Arg3)
    }
  } // End _OSC

  //
  // Declare a _DSM method for various functions called by the OS.
  // See the APCI spec, Section 9.14.1,
  // and the PCI FW spec, Section 4.6.
  // See also:
  // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
  //

  Method (_DSM, 0x4, Serialized) {

    //
    // Match against the _DSM PCI GUID.
    //

    If (LEqual (Arg0,ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

      Switch (ToInteger(Arg2)) {
        //
        // Function 0: Return supported functions as a bitfield
        // with one bit for each supported function.
        // Bit 0 must always be set, as that represents
        // function 0 (which is what is being called here).
        // Support for different functions may depend on
        // the revision ID of the interface, passed as Arg1.
        //

        Case (0) {

            //
            // Functions 0-7 are supported.
            //

            Return (Buffer() {0x01})
        }
      }
    }

    //
    // If not one of the function identifiers we recognize, then return a buffer
    // with bit 0 set to 0 indicating no functions supported.
    //

    Return (Buffer() {0})
  }

  //
  // Root Port 0 Device within the Root Complex.
  //
  Device (RP0) {
    //
    // Device 0, Function 0.
    //

    Name (_ADR, 0x00000000)
  }

  Method (_PXM, 0, NotSerialized) {
    // Patch by code
    Return(0xFF)
  }
} // PCIB RCA3

// PCIC RCA4
Device (PCIC) {
  //
  // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
  // Section 6.1.5
  //

  Name (_HID, "PNP0A08")
  Name (_CCA, ONE)

  Method (_STA, 0, NotSerialized) {
    Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                      // run-time patching as the representation of 0 is special
                                      // encoding and cannot be patched to expand with extra bytes
                                      // easily. As such, we default to 0xF and patch this based
                                      // on whether the port was enabled or not by the BIOS.
  }

  //
  // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
  // root complex for use with pre-PCIe operating systems.
  // Section 6.1.2
  //

  Name (_CID, "PNP0A03")

  //
  // Declare the segment number of this root complex. Most systems only
  // have one segment, which is numbered 0.
  // Section 6.5.6
  //

  Name (_SEG, 8)

  //
  // Declare the base bus number, which is the bus number of the root
  // bus in this root complex. This is usually 0, but need not be.
  // For root complexes supporting multiple root busses, this should
  // be the lowest numbered root bus.
  // Section 6.5.5
  //

  Name (_BBN, 0)

  //
  // The _UID value provides a way of uniquely identifying a device
  // in the case where more than one instance of a specific device
  // is implemented with the same _HID/_CID. For systems with a
  // single root complex, this is usually just 0. For systems with
  // multiple root complexes, this should be different for each
  // root complex.
  // Section 6.1.12
  //

  Name (_UID, "PCIC")
  Name (_STR, Unicode("PCIe 12 Device"))

  //
  // Declare the PCI Routing Table.
  // This defines SPI mappings of the four line-based interrupts
  // associated with the root complex and hierarchy below it.
  // Section 6.2.12
  //

  Name (_PRT, Package() {

    //
    // Routing for device 0, all functions.
    // Note: ARM doesn't support LNK nodes, so the third param
    // is 0 and the fourth param is the SPI number of the interrupt
    // line. In this example, the A/B/C/D interrupts are wired to
    // SPI lines 144/145/146/147 + 320 respectively. PCIC RCA4
    //
    Package() {0x0001FFFF, 0, 0, 464},
    Package() {0x0001FFFF, 1, 0, 465},
    Package() {0x0001FFFF, 2, 0, 466},
    Package() {0x0001FFFF, 3, 0, 467},
    Package() {0x0002FFFF, 0, 0, 464},
    Package() {0x0002FFFF, 1, 0, 465},
    Package() {0x0002FFFF, 2, 0, 466},
    Package() {0x0002FFFF, 3, 0, 467},
    Package() {0x0003FFFF, 0, 0, 464},
    Package() {0x0003FFFF, 1, 0, 465},
    Package() {0x0003FFFF, 2, 0, 466},
    Package() {0x0003FFFF, 3, 0, 467},
    Package() {0x0004FFFF, 0, 0, 464},
    Package() {0x0004FFFF, 1, 0, 465},
    Package() {0x0004FFFF, 2, 0, 466},
    Package() {0x0004FFFF, 3, 0, 467},
    Package() {0x0005FFFF, 0, 0, 464},
    Package() {0x0005FFFF, 1, 0, 465},
    Package() {0x0005FFFF, 2, 0, 466},
    Package() {0x0005FFFF, 3, 0, 467},
    Package() {0x0006FFFF, 0, 0, 464},
    Package() {0x0006FFFF, 1, 0, 465},
    Package() {0x0006FFFF, 2, 0, 466},
    Package() {0x0006FFFF, 3, 0, 467},
    Package() {0x0007FFFF, 0, 0, 464},
    Package() {0x0007FFFF, 1, 0, 465},
    Package() {0x0007FFFF, 2, 0, 466},
    Package() {0x0007FFFF, 3, 0, 467},
    Package() {0x0008FFFF, 0, 0, 464},
    Package() {0x0008FFFF, 1, 0, 465},
    Package() {0x0008FFFF, 2, 0, 466},
    Package() {0x0008FFFF, 3, 0, 467},
  })

  //
  // Declare the resources assigned to this root complex.
  // Section 6.2.2
  //
  Method (_CBA, 0, Serialized) {
    Return (0x63FFF0000000)
  }

  Name (RBUF, ResourceTemplate () {

    //
    // Declare the range of bus numbers assigned to this root
    // complex. In this example, the minimum bus number will be
    // 0, the maximum bus number will be 0xFF, supporting
    // 256 busses total.
    // Section 19.5.141
    //

    WordBusNumber (
      ResourceProducer,
      MinFixed,   // IsMinFixed
      MaxFixed,   // IsMaxFixed
      PosDecode,  // Decode
      0,          // AddressGranularity
      0,          // AddressMinimum - Minimum Bus Number
      255,        // AddressMaximum - Maximum Bus Number
      0,          // AddressTranslation - Set to 0
      256)        // RangeLength - Number of Busses

    //
    // Declare the memory range to be used for BAR memory
    // windows. This declares a 4GB region starting at
    // 0x4000000000.
    // Section 19.5.80
    //
    // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000000040000000,   // AddressMinimum - MIN
      0x0000000047FFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x0000000008000000    // RangeLength - LEN
    )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000600000000000,   // AddressMinimum - MIN
      0x000063FFDFFFFFFF,   // AddressMaximum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x000003FFE0000000    // RangeLength - LEN
    )
  })

  Method (_CRS, 0, Serialized) {
    Return (RBUF)
  }

  //
  // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
  //
  // Argments:
  //   Arg0  A Buffer containing a UUID
  //   Arg1  An Integer containing a Revision ID of the buffer format
  //   Arg2  An Integer containing a count of entries in Arg3
  //   Arg3  A Buffer containing a list of DWORD capabilities
  // Return Value:
  //   A Buffer containing a list of capabilities
  // See the APCI spec, Section 6.2.10,
  // and the PCI FW spec, Section 4.5.
  //
  // The following is an example, and may need modification for
  // specific implementations.
  //

  Name (SUPP,0) // PCI _OSC Support Field value
  Name (CTRL,0) // PCI _OSC Control Field value

  Method (_OSC, 4) {

    //
    // Look for the PCI Host Bridge Interface UUID.
    // Section 6.2.10.3
    //

    //
    // Create DWord-adressable fields from the Capabilities Buffer
    // Create CDW1 outside the test as it's used in the else clause.
    //

    CreateDWordField (Arg3, 0, CDW1)
    If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

      CreateDWordField (Arg3, 4, CDW2)
      CreateDWordField (Arg3, 8, CDW3)

      //
      // Save Capabilities DWord 2 & 3
      //

      Store (CDW2, SUPP)
      Store (CDW3, CTRL)

      //
      // Only allow native hot plug control if OS supports:
      //  ASPM
      //  Clock PM
      //  MSI/MSI-X
      //

      If (LNotEqual (And (SUPP, 0x16), 0x16)) {

        //
        // Mask bit 0 (and undefined bits)
        //

        And (CTRL, 0x1E, CTRL)
      }

      //
      // Never allow native Hot plug, PME.
      // Never allow SHPC (no SHPC controller in this system).
      // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
      // Allows PCI Express Capability Structure control
      //

      if (AERF) {
        And (CTRL, 0x10, CTRL)
      } Else {
        And (CTRL, 0x18, CTRL)
      }

      //
      // Check for unknown revision.
      //

      If (LNotEqual (Arg1, One)) {
        Or (CDW1, 0x08, CDW1)
      }

      //
      // Check if capabilities bits were masked.
      //

      If (LNotEqual (CDW3, CTRL)) {
        Or (CDW1, 0x10, CDW1)
      }

      //
      // Update DWORD3 in the buffer.
      //

      Store (CTRL, CDW3)
      Return (Arg3)

    } Else {

      //
      // Unrecognized UUID
      //

      Or (CDW1, 4, CDW1)
      Return (Arg3)
    }
  } // End _OSC

  //
  // Declare a _DSM method for various functions called by the OS.
  // See the APCI spec, Section 9.14.1,
  // and the PCI FW spec, Section 4.6.
  // See also:
  // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
  //

  Method (_DSM, 0x4, Serialized) {

    //
    // Match against the _DSM PCI GUID.
    //

    If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

      Switch (ToInteger(Arg2)) {
        //
        // Function 0: Return supported functions as a bitfield
        // with one bit for each supported function.
        // Bit 0 must always be set, as that represents
        // function 0 (which is what is being called here).
        // Support for different functions may depend on
        // the revision ID of the interface, passed as Arg1.
        //

        Case (0) {

            //
            // Functions 0-7 are supported.
            //

            Return (Buffer() {0x01})
        }
      }
    }

    //
    // If not one of the function identifiers we recognize, then return a buffer
    // with bit 0 set to 0 indicating no functions supported.
    //

    Return (Buffer() {0})
  }

  //
  // Root Port 0 Device within the Root Complex.
  //
  Device (RP0) {
    //
    // Device 0, Function 0.
    //

    Name (_ADR, 0x00000000)
  }

  Method (_PXM, 0, NotSerialized) {
    // Patch by code
    Return(0xFF)
  }
} // PCIC RCA4

// PCID RCA5
Device (PCID) {
  //
  // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
  // Section 6.1.5
  //

  Name (_HID, "PNP0A08")
  Name (_CCA, ONE)

  Method (_STA, 0, NotSerialized) {
    Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                      // run-time patching as the representation of 0 is special
                                      // encoding and cannot be patched to expand with extra bytes
                                      // easily. As such, we default to 0xF and patch this based
                                      // on whether the port was enabled or not by the BIOS.
  }

  //
  // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
  // root complex for use with pre-PCIe operating systems.
  // Section 6.1.2
  //

  Name (_CID, "PNP0A03")

  //
  // Declare the segment number of this root complex. Most systems only
  // have one segment, which is numbered 0.
  // Section 6.5.6
  //

  Name (_SEG, 9)

  //
  // Declare the base bus number, which is the bus number of the root
  // bus in this root complex. This is usually 0, but need not be.
  // For root complexes supporting multiple root busses, this should
  // be the lowest numbered root bus.
  // Section 6.5.5
  //

  Name (_BBN, 0)

  //
  // The _UID value provides a way of uniquely identifying a device
  // in the case where more than one instance of a specific device
  // is implemented with the same _HID/_CID. For systems with a
  // single root complex, this is usually just 0. For systems with
  // multiple root complexes, this should be different for each
  // root complex.
  // Section 6.1.12
  //

  Name (_UID, "PCID")
  Name (_STR, Unicode("PCIe 13 Device"))

  //
  // Declare the PCI Routing Table.
  // This defines SPI mappings of the four line-based interrupts
  // associated with the root complex and hierarchy below it.
  // Section 6.2.12
  //

  Name (_PRT, Package() {

    //
    // Routing for device 0, all functions.
    // Note: ARM doesn't support LNK nodes, so the third param
    // is 0 and the fourth param is the SPI number of the interrupt
    // line. In this example, the A/B/C/D interrupts are wired to
    // SPI lines 148/149/150/151 + 320 respectively. PCID RCA5
    //
    Package() {0x0001FFFF, 0, 0, 468},
    Package() {0x0001FFFF, 1, 0, 469},
    Package() {0x0001FFFF, 2, 0, 470},
    Package() {0x0001FFFF, 3, 0, 471},
    Package() {0x0002FFFF, 0, 0, 468},
    Package() {0x0002FFFF, 1, 0, 469},
    Package() {0x0002FFFF, 2, 0, 470},
    Package() {0x0002FFFF, 3, 0, 471},
    Package() {0x0003FFFF, 0, 0, 468},
    Package() {0x0003FFFF, 1, 0, 469},
    Package() {0x0003FFFF, 2, 0, 470},
    Package() {0x0003FFFF, 3, 0, 471},
    Package() {0x0004FFFF, 0, 0, 468},
    Package() {0x0004FFFF, 1, 0, 469},
    Package() {0x0004FFFF, 2, 0, 470},
    Package() {0x0004FFFF, 3, 0, 471},
    Package() {0x0005FFFF, 0, 0, 468},
    Package() {0x0005FFFF, 1, 0, 469},
    Package() {0x0005FFFF, 2, 0, 470},
    Package() {0x0005FFFF, 3, 0, 471},
    Package() {0x0006FFFF, 0, 0, 468},
    Package() {0x0006FFFF, 1, 0, 469},
    Package() {0x0006FFFF, 2, 0, 470},
    Package() {0x0006FFFF, 3, 0, 471},
    Package() {0x0007FFFF, 0, 0, 468},
    Package() {0x0007FFFF, 1, 0, 469},
    Package() {0x0007FFFF, 2, 0, 470},
    Package() {0x0007FFFF, 3, 0, 471},
    Package() {0x0008FFFF, 0, 0, 468},
    Package() {0x0008FFFF, 1, 0, 469},
    Package() {0x0008FFFF, 2, 0, 470},
    Package() {0x0008FFFF, 3, 0, 471},
  })

  //
  // Declare the resources assigned to this root complex.
  // Section 6.2.2
  //
  Method (_CBA, 0, Serialized) {
    Return (0x67FFF0000000)
  }

  Name (RBUF, ResourceTemplate () {

    //
    // Declare the range of bus numbers assigned to this root
    // complex. In this example, the minimum bus number will be
    // 0, the maximum bus number will be 0xFF, supporting
    // 256 busses total.
    // Section 19.5.141
    //

    WordBusNumber (
      ResourceProducer,
      MinFixed,   // IsMinFixed
      MaxFixed,   // IsMaxFixed
      PosDecode,  // Decode
      0,          // AddressGranularity
      0,          // AddressMinimum - Minimum Bus Number
      255,        // AddressMaximum - Maximum Bus Number
      0,          // AddressTranslation - Set to 0
      256)        // RangeLength - Number of Busses

    //
    // Declare the memory range to be used for BAR memory
    // windows. This declares a 4GB region starting at
    // 0x4000000000.
    // Section 19.5.80
    //
    // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000000048000000,   // AddressMinimum - MIN
      0x000000004FFFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x0000000008000000    // RangeLength - LEN
    )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000640000000000,   // AddressMinimum - MIN
      0x000067FFDFFFFFFF,   // AddressMaximum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x000003FFE0000000    // RangeLength - LEN
    )
  })

  Method (_CRS, 0, Serialized) {
    Return (RBUF)
  }

  //
  // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
  //
  // Argments:
  //   Arg0  A Buffer containing a UUID
  //   Arg1  An Integer containing a Revision ID of the buffer format
  //   Arg2  An Integer containing a count of entries in Arg3
  //   Arg3  A Buffer containing a list of DWORD capabilities
  // Return Value:
  //   A Buffer containing a list of capabilities
  // See the APCI spec, Section 6.2.10,
  // and the PCI FW spec, Section 4.5.
  //
  // The following is an example, and may need modification for
  // specific implementations.
  //

  Name (SUPP,0) // PCI _OSC Support Field value
  Name (CTRL,0) // PCI _OSC Control Field value

  Method (_OSC, 4) {

    //
    // Look for the PCI Host Bridge Interface UUID.
    // Section 6.2.10.3
    //

    //
    // Create DWord-adressable fields from the Capabilities Buffer
    // Create CDW1 outside the test as it's used in the else clause.
    //

    CreateDWordField (Arg3, 0, CDW1)
    If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

      CreateDWordField (Arg3, 4, CDW2)
      CreateDWordField (Arg3, 8, CDW3)

      //
      // Save Capabilities DWord 2 & 3
      //

      Store (CDW2, SUPP)
      Store (CDW3, CTRL)

      //
      // Only allow native hot plug control if OS supports:
      //  ASPM
      //  Clock PM
      //  MSI/MSI-X
      //

      If (LNotEqual (And (SUPP, 0x16), 0x16)) {

        //
        // Mask bit 0 (and undefined bits)
        //

        And (CTRL, 0x1E, CTRL)
      }

      //
      // Never allow native Hot plug, PME.
      // Never allow SHPC (no SHPC controller in this system).
      // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
      // Allows PCI Express Capability Structure control
      //

      if (AERF) {
        And (CTRL, 0x10, CTRL)
      } Else {
        And (CTRL, 0x18, CTRL)
      }

      //
      // Check for unknown revision.
      //

      If (LNotEqual (Arg1, One)) {
        Or (CDW1, 0x08, CDW1)
      }

      //
      // Check if capabilities bits were masked.
      //

      If (LNotEqual (CDW3, CTRL)) {
        Or (CDW1, 0x10, CDW1)
      }

      //
      // Update DWORD3 in the buffer.
      //

      Store (CTRL, CDW3)
      Return (Arg3)

    } Else {

      //
      // Unrecognized UUID
      //

      Or (CDW1, 4, CDW1)
      Return (Arg3)
    }
  } // End _OSC

  //
  // Declare a _DSM method for various functions called by the OS.
  // See the APCI spec, Section 9.14.1,
  // and the PCI FW spec, Section 4.6.
  // See also:
  // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
  //

  Method (_DSM, 0x4, Serialized) {

    //
    // Match against the _DSM PCI GUID.
    //

    If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

      Switch (ToInteger(Arg2)) {
        //
        // Function 0: Return supported functions as a bitfield
        // with one bit for each supported function.
        // Bit 0 must always be set, as that represents
        // function 0 (which is what is being called here).
        // Support for different functions may depend on
        // the revision ID of the interface, passed as Arg1.
        //

        Case (0) {

            //
            // Functions 0-7 are supported.
            //

            Return (Buffer() {0x01})
        }
      }
    }

    //
    // If not one of the function identifiers we recognize, then return a buffer
    // with bit 0 set to 0 indicating no functions supported.
    //

    Return (Buffer() {0})
  }

  //
  // Root Port 0 Device within the Root Complex.
  //
  Device (RP0) {
    //
    // Device 0, Function 0.
    //

    Name (_ADR, 0x00000000)
  }

  //
  // Root Port 1
  //
  Device (P2P1) {
    //
    // Device 1, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00010000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 1 [01])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A150 == 0xF0000501) { // SW ejected ?
          Store(0x02000501, A150) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000219, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000219 to DBNS1_10
          Return(0xF)
        }
        elseif (A150 == 0x10000501) { // ejected complete ?
          Store(0x02000501, A150) // clear action value
          Return(0x0)
        }
        elseif ((A150 == 0x01000501) || (A150 == 0x0F000501)) { // inserted?
          if (A16I == 0x00) {
            Store(0x02000501, A150) // clear action value
          }
          Return(0xF)
        }
        elseif ((A150 == 0x0E000501) || (A150 == 0x0F000501)) { // inprogress inserted?
          if (A16I == 0x00) {
            Store(0x02000501, A150) // clear action value
          }
          Return(0xF)
        }
        else {
          Return(0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A150 == 0x02000501) { // really sw ejection call?
          Store(0xF0000501, A150) // set SW ejection action
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000219, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000219 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000001)
    }
  }

  //
  // Root Port 2
  //
  Device (P2P2) {
    //
    // Device 2, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00020000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 2 [02])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A151 == 0xF0010501) { // SW ejected ?
          Store(0x02010501, A151) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000229, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000229 to DBNS1_10
          Return(0xF)
        }
        elseif (A151 == 0x10010501) { // ejected complete ?
          Store(0x02010501, A151) // clear action value
          Return(0x0)
        }
        elseif ((A151 == 0x01010501) || (A151 == 0x0F010501)) { // inserted?
          if (A17I == 0x00) {
            Store(0x02010501, A151) // clear action value
          }
          Return(0xF)
        }
        elseif ((A151 == 0x0E010501) || (A151 == 0x0F010501)) { // inprogress inserted?
          if (A17I == 0x00) {
            Store(0x02010501, A151) // clear action value
          }
          Return(0xF)
        }
        else {
          Return(0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A151 == 0x02010501) { // really sw ejection call?
          Store(0xF0010501, A151) // set SW ejection action
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000229, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000229 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000002)
    }
  }

  //
  // Root Port 3
  //
  Device (P2P3) {
    //
    // Device 3, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00030000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 3 [03])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A152 == 0xF0020501) { // SW ejected ?
          Store(0x02020501, A152) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000239, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000239 to DBNS1_10
          Return(0xF)
        }
        elseif (A152 == 0x10020501) { // ejected complete ?
          Store(0x02020501, A152) // clear action value
          Return(0x0)
        }
        elseif ((A152 == 0x01020501) || (A152 == 0x0F020501)) { // inserted?
          if (A18I == 0x00) {
            Store(0x02020501, A152) // clear action value
          }
          Return(0xF)
        }
        elseif ((A152 == 0x0E020501) || (A152 == 0x0F020501)) { // inprogress inserted?
          if (A18I == 0x00) {
            Store(0x02020501, A152) // clear action value
          }
          Return(0xF)
        }
        else {
          Return(0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A152 == 0x02020501) { // really sw ejection call?
          Store(0xF0020501, A152) // set SW ejection action
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000239, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000239 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000003)
    }
  }

  //
  // Root Port 4
  //
  Device (P2P4) {
    //
    // Device 4, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00040000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 4 ([04])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A153 == 0xF0030501) { // SW ejected ?
          Store(0x02030501, A153) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000249, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000249 to DBNS1_10
          Return(0xF)
        }
        elseif(A153 == 0x10030501) { // ejected complete ?
          Store(0x02030501, A153) // clear action value
          Return(0x0)
        }
        elseif((A153 == 0x01030501) || (A153 == 0x0F030501)) { // inserted ?
          if (A19I == 0x00) {
            Store(0x02030501, A153) // clear action value
          }
          Return(0xF)
        }
        elseif((A153 == 0x0E030501) || (A153 == 0x0F030501)) { // inprogress inserted ?
          if (A19I == 0x00) {
            Store(0x02030501, A153) // clear action value
          }
          Return(0xF)
        }
        else {
          Return(0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A153 == 0x02030501) { // really sw ejection call?
          Store(0xF0030501, A153) // set SW ejection value
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x68000249, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x68000249 to DBNS1_10
        }
      }

      Name(_SUN, 0x00000004)
    }
  }

  Method (_PXM, 0, NotSerialized) {
    // Patch by code
    Return(0xFF)
  }
} // PCID RCA5

// PCIE RCA6
Device (PCIE) {
  //
  // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
  // Section 6.1.5
  //

  Name (_HID, "PNP0A08")
  Name (_CCA, ONE)

  Method (_STA, 0, NotSerialized) {
    Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                      // run-time patching as the representation of 0 is special
                                      // encoding and cannot be patched to expand with extra bytes
                                      // easily. As such, we default to 0xF and patch this based
                                      // on whether the port was enabled or not by the BIOS.
  }

  //
  // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
  // root complex for use with pre-PCIe operating systems.
  // Section 6.1.2
  //

  Name (_CID, "PNP0A03")

  //
  // Declare the segment number of this root complex. Most systems only
  // have one segment, which is numbered 0.
  // Section 6.5.6
  //

  Name (_SEG, 10)

  //
  // Declare the base bus number, which is the bus number of the root
  // bus in this root complex. This is usually 0, but need not be.
  // For root complexes supporting multiple root busses, this should
  // be the lowest numbered root bus.
  // Section 6.5.5
  //

  Name (_BBN, 0)

  //
  // The _UID value provides a way of uniquely identifying a device
  // in the case where more than one instance of a specific device
  // is implemented with the same _HID/_CID. For systems with a
  // single root complex, this is usually just 0. For systems with
  // multiple root complexes, this should be different for each
  // root complex.
  // Section 6.1.12
  //

  Name (_UID, "PCIE")
  Name (_STR, Unicode("PCIe 14 Device"))

  //
  // Declare the PCI Routing Table.
  // This defines SPI mappings of the four line-based interrupts
  // associated with the root complex and hierarchy below it.
  // Section 6.2.12
  //

  Name (_PRT, Package() {

    //
    // Routing for device 0, all functions.
    // Note: ARM doesn't support LNK nodes, so the third param
    // is 0 and the fourth param is the SPI number of the interrupt
    // line. In this example, the A/B/C/D interrupts are wired to
    // SPI lines 152/153/154/155 + 320 respectively. PCIE RCA6
    //
    Package() {0x0001FFFF, 0, 0, 472},
    Package() {0x0001FFFF, 1, 0, 473},
    Package() {0x0001FFFF, 2, 0, 474},
    Package() {0x0001FFFF, 3, 0, 475},
    Package() {0x0002FFFF, 0, 0, 472},
    Package() {0x0002FFFF, 1, 0, 473},
    Package() {0x0002FFFF, 2, 0, 474},
    Package() {0x0002FFFF, 3, 0, 475},
    Package() {0x0003FFFF, 0, 0, 472},
    Package() {0x0003FFFF, 1, 0, 473},
    Package() {0x0003FFFF, 2, 0, 474},
    Package() {0x0003FFFF, 3, 0, 475},
    Package() {0x0004FFFF, 0, 0, 472},
    Package() {0x0004FFFF, 1, 0, 473},
    Package() {0x0004FFFF, 2, 0, 474},
    Package() {0x0004FFFF, 3, 0, 475},
    Package() {0x0005FFFF, 0, 0, 472},
    Package() {0x0005FFFF, 1, 0, 473},
    Package() {0x0005FFFF, 2, 0, 474},
    Package() {0x0005FFFF, 3, 0, 475},
    Package() {0x0006FFFF, 0, 0, 472},
    Package() {0x0006FFFF, 1, 0, 473},
    Package() {0x0006FFFF, 2, 0, 474},
    Package() {0x0006FFFF, 3, 0, 475},
    Package() {0x0007FFFF, 0, 0, 472},
    Package() {0x0007FFFF, 1, 0, 473},
    Package() {0x0007FFFF, 2, 0, 474},
    Package() {0x0007FFFF, 3, 0, 475},
    Package() {0x0008FFFF, 0, 0, 472},
    Package() {0x0008FFFF, 1, 0, 473},
    Package() {0x0008FFFF, 2, 0, 474},
    Package() {0x0008FFFF, 3, 0, 475},
  })

  //
  // Declare the resources assigned to this root complex.
  // Section 6.2.2
  //
  Method (_CBA, 0, Serialized) {
    Return (0x6BFFF0000000)
  }

  Name (RBUF, ResourceTemplate () {

    //
    // Declare the range of bus numbers assigned to this root
    // complex. In this example, the minimum bus number will be
    // 0, the maximum bus number will be 0xFF, supporting
    // 256 busses total.
    // Section 19.5.141
    //

    WordBusNumber (
      ResourceProducer,
      MinFixed,   // IsMinFixed
      MaxFixed,   // IsMaxFixed
      PosDecode,  // Decode
      0,          // AddressGranularity
      0,          // AddressMinimum - Minimum Bus Number
      255,        // AddressMaximum - Maximum Bus Number
      0,          // AddressTranslation - Set to 0
      256)        // RangeLength - Number of Busses

    //
    // Declare the memory range to be used for BAR memory
    // windows. This declares a 4GB region starting at
    // 0x4000000000.
    // Section 19.5.80
    //
    // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000000050000000,   // AddressMinimum - MIN
      0x0000000057FFFFFF,   // AddressMaximum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x0000000008000000    // RangeLength - LEN
    )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000680000000000,   // AddressMinimum - MIN
      0x00006BFFDFFFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x000003FFE0000000    // RangeLength - LEN
    )
  })

  Method (_CRS, 0, Serialized) {
    Return (RBUF)
  }

  //
  // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
  //
  // Argments:
  //   Arg0  A Buffer containing a UUID
  //   Arg1  An Integer containing a Revision ID of the buffer format
  //   Arg2  An Integer containing a count of entries in Arg3
  //   Arg3  A Buffer containing a list of DWORD capabilities
  // Return Value:
  //   A Buffer containing a list of capabilities
  // See the APCI spec, Section 6.2.10,
  // and the PCI FW spec, Section 4.5.
  //
  // The following is an example, and may need modification for
  // specific implementations.
  //

  Name (SUPP,0) // PCI _OSC Support Field value
  Name (CTRL,0) // PCI _OSC Control Field value

  Method (_OSC, 4) {

    //
    // Look for the PCI Host Bridge Interface UUID.
    // Section 6.2.10.3
    //

    //
    // Create DWord-adressable fields from the Capabilities Buffer
    // Create CDW1 outside the test as it's used in the else clause.
    //

    CreateDWordField (Arg3, 0, CDW1)
    If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

      CreateDWordField (Arg3, 4, CDW2)
      CreateDWordField (Arg3, 8, CDW3)

      //
      // Save Capabilities DWord 2 & 3
      //

      Store (CDW2, SUPP)
      Store (CDW3, CTRL)

      //
      // Only allow native hot plug control if OS supports:
      //  ASPM
      //  Clock PM
      //  MSI/MSI-X
      //

      If (LNotEqual (And (SUPP, 0x16), 0x16)) {

        //
        // Mask bit 0 (and undefined bits)
        //

        And (CTRL, 0x1E, CTRL)
      }

      //
      // Never allow native Hot plug, PME.
      // Never allow SHPC (no SHPC controller in this system).
      // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
      // Allows PCI Express Capability Structure control
      //

      if (AERF) {
        And (CTRL, 0x10, CTRL)
      } Else {
        And (CTRL, 0x18, CTRL)
      }

      //
      // Check for unknown revision.
      //

      If (LNotEqual (Arg1, One)) {
        Or (CDW1, 0x08, CDW1)
      }

      //
      // Check if capabilities bits were masked.
      //

      If (LNotEqual (CDW3, CTRL)) {
        Or (CDW1, 0x10, CDW1)
      }

      //
      // Update DWORD3 in the buffer.
      //

      Store (CTRL, CDW3)
      Return (Arg3)

    } Else {

      //
      // Unrecognized UUID
      //

      Or (CDW1, 4, CDW1)
      Return (Arg3)
    }
  } // End _OSC

  //
  // Declare a _DSM method for various functions called by the OS.
  // See the APCI spec, Section 9.14.1,
  // and the PCI FW spec, Section 4.6.
  // See also:
  // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
  //

  Method (_DSM, 0x4, Serialized) {

    //
    // Match against the _DSM PCI GUID.
    //

    If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

      Switch (ToInteger(Arg2)) {
        //
        // Function 0: Return supported functions as a bitfield
        // with one bit for each supported function.
        // Bit 0 must always be set, as that represents
        // function 0 (which is what is being called here).
        // Support for different functions may depend on
        // the revision ID of the interface, passed as Arg1.
        //

        Case (0) {

            //
            // Functions 0-7 are supported.
            //

            Return (Buffer() {0x01})
        }
      }
    }

    //
    // If not one of the function identifiers we recognize, then return a buffer
    // with bit 0 set to 0 indicating no functions supported.
    //

    Return (Buffer() {0})
  }

  //
  // Root Port 0 Device within the Root Complex.
  //
  Device (RP0) {
    //
    // Device 0, Function 0.
    //

    Name (_ADR, 0x00000000)
  }

  //
  // Root Port 1
  //
  Device (P2P1) {
    //
    // Device 1, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00010000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 1 ([01])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A160 == 0xF0000601) { // SW ejected before ?
          Store(0x02000601, A160) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800021A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800021A to DBNS1_10
          Return(0xF)
        }
        elseif (A160 == 0x10000601) { // ejected complete ?
          Store(0x02000601, A160) // clear action value
          Return (0x0)
        }
        elseif ((A160 == 0x01000601) || (A160 == 0x0F000601)){ // inserted ?
          if (A11I == 0x00) {
            Store(0x02000601, A160) // clear action value
          }
          Return (0xF)
        }
        elseif ((A160 == 0x0E000601) || (A160 == 0x0F000601)) { // inprogress inserted ?
          if (A11I == 0x00) {
            Store(0x02000601, A160) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A160 == 0x02000601) { // is sw ejection?
          Store(0xF0000601, A160) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800021A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800021A to DBNS1_10
        }
      }

      Name(_SUN, 0x00000001)
    }
  }

  //
  // Root Port 2
  //
  Device (P2P2) {
    //
    // Device 2, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00020000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 2 [02])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A161 == 0xF0010601) { // SW ejected before ?
          Store(0x02010601, A161) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800022A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800022A to DBNS1_10
          Return(0xF)
        }
        elseif (A161 == 0x10010601) { // ejected completed ?
          Store(0x02010601, A161) // clear action value
          Return (0x0)
        }
        elseif ((A161 == 0x01010601) || (A161 == 0x0F010601)){ // inserted ?
          if (A10I == 0x00) {
            Store(0x02010601, A161) // clear action value
          }
          Return (0xF)
        }
        elseif ((A161 == 0x0E010601) || (A161 == 0x0F010601)) { // inprogress inserted ?
          if (A10I == 0x00) {
            Store(0x02010601, A161) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A161 == 0x02010601) { // is sw ejection?
          Store(0xF0010601, A161) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800022A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800022A to DBNS1_10
        }
      }

      Name(_SUN, 0x00000002)
    }
  }

  //
  // Root Port 3
  //
  Device (P2P3) {
    //
    // Device 3, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00030000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 3 [03])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A162 == 0xF0020601) { // SW ejected before ?
          Store(0x02020601, A162) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800023A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800023A to DBNS1_10
          Return(0xF)
        }
        elseif (A162 == 0x10020601) { // ejected complete ?
          Store(0x02020601, A162) // clear action value
          Return (0x0)
        }
        elseif ((A162 == 0x01020601) || (A162 == 0x0F020601)) { // inserted ?
          if (A09I == 0x00) {
            Store(0x02020601, A162) // clear action value
          }
          Return (0xF)
        }
        elseif ((A162 == 0x0E020601) || (A162 == 0x0F020601)) { // inprogress inserted ?
          if (A09I == 0x00) {
            Store(0x02020601, A162) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A162 == 0x02020601) { // is sw ejection?
          Store(0xF0020601, A162) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800023A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800023A to DBNS1_10
        }
      }

      Name(_SUN, 0x00000003)
    }
  }

  //
  // Root Port 4
  //
  Device (P2P4) {
    //
    // Device 4, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00040000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 4 ([04])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A163 == 0xF0030601) { // SW ejected before ?
          Store(0x02030601, A163) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800024A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800024A to DBNS1_10
          Return(0xF)
        }
        elseif (A163 == 0x10030601) { // ejected complete ?
          Store(0x02030601, A163) // clear action value
          Return (0x0)
        }
        elseif ((A163 == 0x01030601) || (A163 == 0x0F030601)) { // inserted ?
          if (A08I == 0x00) {
            Store(0x02030601, A163) // clear action value
          }
          Return (0xF)
        }
        elseif ((A163 == 0x0E030601) || (A163 == 0x0F030601)) { // inprogress inserted ?
          if (A08I == 0x00) {
            Store(0x02030601, A163) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A163 == 0x02030601) { // is sw ejection?
          Store(0xF0030601, A163) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800024A, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800024A to DBNS1_10
        }
      }

      Name(_SUN, 0x00000004)
    }
  }

  Method (_PXM, 0, NotSerialized) {
    // Patch by code
    Return(0xFF)
  }
} // PCIE RCA6

// PCIF RCA7
Device (PCIF) {
  //
  // Hardware ID must be PNP0A08, which maps to a PCIe root complex.
  // Section 6.1.5
  //

  Name (_HID, "PNP0A08")
  Name (_CCA, ONE)

  Method (_STA, 0, NotSerialized) {
    Return (0xF)                      // The default value is 0x0. Unfortunately, it breaks
                                      // run-time patching as the representation of 0 is special
                                      // encoding and cannot be patched to expand with extra bytes
                                      // easily. As such, we default to 0xF and patch this based
                                      // on whether the port was enabled or not by the BIOS.
  }

  //
  // Optionally, include a compatible ID of PNP0A03, which maps to a PCI
  // root complex for use with pre-PCIe operating systems.
  // Section 6.1.2
  //

  Name (_CID, "PNP0A03")

  //
  // Declare the segment number of this root complex. Most systems only
  // have one segment, which is numbered 0.
  // Section 6.5.6
  //

  Name (_SEG, 11)

  //
  // Declare the base bus number, which is the bus number of the root
  // bus in this root complex. This is usually 0, but need not be.
  // For root complexes supporting multiple root busses, this should
  // be the lowest numbered root bus.
  // Section 6.5.5
  //

  Name (_BBN, 0)

  //
  // The _UID value provides a way of uniquely identifying a device
  // in the case where more than one instance of a specific device
  // is implemented with the same _HID/_CID. For systems with a
  // single root complex, this is usually just 0. For systems with
  // multiple root complexes, this should be different for each
  // root complex.
  // Section 6.1.12
  //

  Name (_UID, "PCIF")
  Name (_STR, Unicode("PCIe 15 Device"))

  //
  // Declare the PCI Routing Table.
  // This defines SPI mappings of the four line-based interrupts
  // associated with the root complex and hierarchy below it.
  // Section 6.2.12
  //

  Name (_PRT, Package() {

    //
    // Routing for device 0, all functions.
    // Note: ARM doesn't support LNK nodes, so the third param
    // is 0 and the fourth param is the SPI number of the interrupt
    // line. In this example, the A/B/C/D interrupts are wired to
    // SPI lines 156/157/158/159 + 320 respectively. PCIF RCA7
    //
    Package() {0x0001FFFF, 0, 0, 476},
    Package() {0x0001FFFF, 1, 0, 477},
    Package() {0x0001FFFF, 2, 0, 478},
    Package() {0x0001FFFF, 3, 0, 479},
    Package() {0x0002FFFF, 0, 0, 476},
    Package() {0x0002FFFF, 1, 0, 477},
    Package() {0x0002FFFF, 2, 0, 478},
    Package() {0x0002FFFF, 3, 0, 479},
    Package() {0x0003FFFF, 0, 0, 476},
    Package() {0x0003FFFF, 1, 0, 477},
    Package() {0x0003FFFF, 2, 0, 478},
    Package() {0x0003FFFF, 3, 0, 479},
    Package() {0x0004FFFF, 0, 0, 476},
    Package() {0x0004FFFF, 1, 0, 477},
    Package() {0x0004FFFF, 2, 0, 478},
    Package() {0x0004FFFF, 3, 0, 479},
    Package() {0x0005FFFF, 0, 0, 476},
    Package() {0x0005FFFF, 1, 0, 477},
    Package() {0x0005FFFF, 2, 0, 478},
    Package() {0x0005FFFF, 3, 0, 479},
    Package() {0x0006FFFF, 0, 0, 476},
    Package() {0x0006FFFF, 1, 0, 477},
    Package() {0x0006FFFF, 2, 0, 478},
    Package() {0x0006FFFF, 3, 0, 479},
    Package() {0x0007FFFF, 0, 0, 476},
    Package() {0x0007FFFF, 1, 0, 477},
    Package() {0x0007FFFF, 2, 0, 478},
    Package() {0x0007FFFF, 3, 0, 479},
    Package() {0x0008FFFF, 0, 0, 476},
    Package() {0x0008FFFF, 1, 0, 477},
    Package() {0x0008FFFF, 2, 0, 478},
    Package() {0x0008FFFF, 3, 0, 479},
  })

  //
  // Declare the resources assigned to this root complex.
  // Section 6.2.2
  //
  Method (_CBA, 0, Serialized) {
    Return (0x6FFFF0000000)
  }

  Name (RBUF, ResourceTemplate () {

    //
    // Declare the range of bus numbers assigned to this root
    // complex. In this example, the minimum bus number will be
    // 0, the maximum bus number will be 0xFF, supporting
    // 256 busses total.
    // Section 19.5.141
    //

    WordBusNumber (
      ResourceProducer,
      MinFixed,   // IsMinFixed
      MaxFixed,   // IsMaxFixed
      PosDecode,  // Decode
      0,          // AddressGranularity
      0,          // AddressMinimum - Minimum Bus Number
      255,        // AddressMaximum - Maximum Bus Number
      0,          // AddressTranslation - Set to 0
      256)        // RangeLength - Number of Busses

    //
    // Declare the memory range to be used for BAR memory
    // windows. This declares a 4GB region starting at
    // 0x4000000000.
    // Section 19.5.80
    //
    // Memory32Fixed (ReadWrite, 0x1FE40000, 0x10000, )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x0000000058000000,   // AddressMinimum - MIN
      0x000000005FFFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x0000000008000000    // RangeLength - LEN
    )

    QWordMemory (
      ResourceProducer,     // ResourceUsage
      PosDecode,            // Decode
      MinFixed,             // IsMinFixed
      MaxFixed,             // IsMaxFixed
      NonCacheable,         // NonCacheable
      ReadWrite,            // ReadAndWrite
      0x0000000000000000,   // AddressGranularity - GRA
      0x00006C0000000000,   // AddressMinimum - MIN
      0x00006FFFDFFFFFFF,   // AddressMinimum - MAX
      0x0000000000000000,   // AddressTranslation - TRA
      0x000003FFE0000000    // RangeLength - LEN
    )
  })

  Method (_CRS, 0, Serialized) {
    Return (RBUF)
  }

  //
  // Declare an _OSC (OS Control Handoff) method which takes 4 arguments.
  //
  // Argments:
  //   Arg0  A Buffer containing a UUID
  //   Arg1  An Integer containing a Revision ID of the buffer format
  //   Arg2  An Integer containing a count of entries in Arg3
  //   Arg3  A Buffer containing a list of DWORD capabilities
  // Return Value:
  //   A Buffer containing a list of capabilities
  // See the APCI spec, Section 6.2.10,
  // and the PCI FW spec, Section 4.5.
  //
  // The following is an example, and may need modification for
  // specific implementations.
  //

  Name (SUPP,0) // PCI _OSC Support Field value
  Name (CTRL,0) // PCI _OSC Control Field value

  Method (_OSC, 4) {

    //
    // Look for the PCI Host Bridge Interface UUID.
    // Section 6.2.10.3
    //

    //
    // Create DWord-adressable fields from the Capabilities Buffer
    // Create CDW1 outside the test as it's used in the else clause.
    //

    CreateDWordField (Arg3, 0, CDW1)
    If (LEqual (Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {

      CreateDWordField (Arg3, 4, CDW2)
      CreateDWordField (Arg3, 8, CDW3)

      //
      // Save Capabilities DWord 2 & 3
      //

      Store (CDW2, SUPP)
      Store (CDW3, CTRL)

      //
      // Only allow native hot plug control if OS supports:
      //  ASPM
      //  Clock PM
      //  MSI/MSI-X
      //

      If (LNotEqual (And (SUPP, 0x16), 0x16)) {

        //
        // Mask bit 0 (and undefined bits)
        //

        And (CTRL, 0x1E, CTRL)
      }

      //
      // Never allow native Hot plug, PME.
      // Never allow SHPC (no SHPC controller in this system).
      // Only allow PCIe AER control if PCIe AER Firmware-First is disabled
      // Allows PCI Express Capability Structure control
      //

      if (AERF) {
        And (CTRL, 0x10, CTRL)
      } Else {
        And (CTRL, 0x18, CTRL)
      }

      //
      // Check for unknown revision.
      //

      If (LNotEqual (Arg1, One)) {
        Or (CDW1, 0x08, CDW1)
      }

      //
      // Check if capabilities bits were masked.
      //

      If (LNotEqual (CDW3, CTRL)) {
        Or (CDW1, 0x10, CDW1)
      }

      //
      // Update DWORD3 in the buffer.
      //

      Store (CTRL, CDW3)
      Return (Arg3)

    } Else {

      //
      // Unrecognized UUID
      //

      Or (CDW1, 4, CDW1)
      Return (Arg3)
    }
  } // End _OSC

  //
  // Declare a _DSM method for various functions called by the OS.
  // See the APCI spec, Section 9.14.1,
  // and the PCI FW spec, Section 4.6.
  // See also:
  // http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/PCI-rsc.doc
  //

  Method (_DSM, 0x4, Serialized) {

    //
    // Match against the _DSM PCI GUID.
    //

    If (LEqual (Arg0, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {

      Switch (ToInteger(Arg2)) {
        //
        // Function 0: Return supported functions as a bitfield
        // with one bit for each supported function.
        // Bit 0 must always be set, as that represents
        // function 0 (which is what is being called here).
        // Support for different functions may depend on
        // the revision ID of the interface, passed as Arg1.
        //

        Case (0) {

            //
            // Functions 0-7 are supported.
            //

            Return (Buffer() {0x01})
        }
      }
    }

    //
    // If not one of the function identifiers we recognize, then return a buffer
    // with bit 0 set to 0 indicating no functions supported.
    //

    Return (Buffer() {0})
  }

  //
  // Root Port 0 Device within the Root Complex.
  //
  Device (RP0) {
    //
    // Device 0, Function 0.
    //

    Name (_ADR, 0x00000000)
  }

  //
  // Root Port 1
  //
  Device (P2P1) {
    //
    // Device 1, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00010000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 1 ([01])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A170 == 0xF0000701) { // SW ejected before ?
          Store(0x02000701, A170) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800021B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800021B to DBNS1_10
          Return(0xF)
        }
        elseif (A170 == 0x10000701) { // ejected complete ?
          Store(0x02000701, A170) // clear action value
          Return (0x0)
        }
        elseif ((A170 == 0x01000701) || (A170 == 0x0F000701)){ // inserted ?
          if (A15I == 0x00) {
            Store(0x02000701, A170) // clear action value
          }
          Return (0xF)
        }
        elseif ((A170 == 0x0E000701) || (A170 == 0x0F000701)) { // inprogress inserted ?
          if (A15I == 0x00) {
            Store(0x02000701, A170) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A170 == 0x02000701) { // is sw ejection?
          Store(0xF0000701, A170) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800021B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800021B to DBNS1_10
        }
      }

      Name(_SUN, 0x00000001)
    }
  }

  //
  // Root Port 2
  //
  Device (P2P2) {
    //
    // Device 2, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00020000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 2 [02])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A171 == 0xF0010701) { // SW ejected before ?
          Store(0x02010701, A171) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800022B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800022B to DBNS1_10
          Return(0xF)
        }
        elseif (A171 == 0x10010701) { // ejected completed ?
          Store(0x02010701, A171) // clear action value
          Return (0x0)
        }
        elseif ((A171 == 0x01010701) || (A171 == 0x0F010701)){ // inserted ?
          if (A14I == 0x00) {
            Store(0x02010701, A171) // clear action value
          }
          Return (0xF)
        }
        elseif ((A171 == 0x0E010701) || (A171 == 0x0F010701)) { // inprogress inserted ?
          if (A14I == 0x00) {
            Store(0x02010701, A171) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A171 == 0x02010701) { // is sw ejection?
          Store(0xF0010701, A171) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800022B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800022B to DBNS1_10
        }
      }

      Name(_SUN, 0x00000002)
    }
  }

  //
  // Root Port 3
  //
  Device (P2P3) {
    //
    // Device 3, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00030000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 3 [03])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A172 == 0xF0020701) { // SW ejected before ?
          Store(0x02020701, A172) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800023B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800023B to DBNS1_10
          Return(0xF)
        }
        elseif (A172 == 0x10020701) { // ejected complete ?
          Store(0x02020701, A172) // clear action value
          Return (0x0)
        }
        elseif ((A172 == 0x01020701) || (A172 == 0x0F020701)) { // inserted ?
          if (A13I == 0x00) {
            Store(0x02020701, A172) // clear action value
          }
          Return (0xF)
        }
        elseif ((A172 == 0x0E020701) || (A172 == 0x0F020701)) { // inprogress inserted ?
          if (A13I == 0x00) {
            Store(0x02020701, A172) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A172 == 0x02020701) { // is sw ejection?
          Store(0xF0020701, A172) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800023B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800023B to DBNS1_10
        }
      }

      Name(_SUN, 0x00000003)
    }
  }

  //
  // Root Port 4
  //
  Device (P2P4) {
    //
    // Device 4, Function 0 (Bus 0).
    //

    Name (_ADR, 0x00040000)
    Name(_HPP, Package(){0x08,0x40, 0x01, 0x00})

    Device (S0F0) {
      //
      // On Bus 4 ([04])
      // Slot 0 (Device 0), Function 0
      //

      Name (_ADR, 0x00000000)

      Method (_STA, 0) {
        if (A173 == 0xF0030701) { // SW ejected before ?
          Store(0x02030701, A173) // clear action value
          Store(0x680000A4, DIN0) // Off RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800024B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800024B to DBNS1_10
          Return(0xF)
        }
        elseif (A173 == 0x10030701) { // ejected complete ?
          Store(0x02030701, A173) // clear action value
          Return (0x0)
        }
        elseif ((A173 == 0x01030701) || (A173 == 0x0F030701)) { // inserted ?
          if (A12I == 0x00) {
            Store(0x02030701, A173) // clear action value
          }
          Return (0xF)
        }
        elseif ((A173 == 0x0E030701) || (A173 == 0x0F030701)) { // inprogress inserted ?
          if (A12I == 0x00) {
            Store(0x02030701, A173) // clear action value
          }
          Return (0xF)
        }
        else {
          Return (0xF)
        }
      }

      Method (_EJ0, 1) {
        if (A173 == 0x02030701) { // is sw ejection?
          Store(0xF0030701, A173) // set SW ejection event
          Store(0x680000B4, DIN0) // Blink RED LED
                                  // <Led:6-7.Led_action:4-5.Ampere_HP_CMD:0-3>
                                  // Ampere_HP_CMD: LED_CMD = 4, HP_CHG_CMD = 3
          Store(0x6800024B, OUTV) // <MsgType(0x6)-Hdlr(0x8).Resv.action.dev.segment>
                                  // action: Insert = 1 & Remove = 2
                                  // 0x6800024B to DBNS1_10
        }
      }

      Name(_SUN, 0x00000004)
    }
  }

  Method (_PXM, 0, NotSerialized) {
    // Patch by code
    Return(0xFF)
  }
} // PCIF RCA7
